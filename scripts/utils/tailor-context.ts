import { existsSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import { join } from 'path';
import yaml from 'js-yaml';
import { pipe } from 'remeda';
import { match, P } from 'ts-pattern';
import { MetadataSchema, JobAnalysisSchema } from '../../src/zod/schemas';
import type { z } from 'zod';

// Result type for functional error handling
export type Result<T, E = { error: string; details?: string }> =
  | { success: true; data: T }
  | ({ success: false } & E);

export interface SetContextSuccess {
  success: true;
  data: {
    company: string;
    path: string;
    availableFiles: string[];
    position: string;
    primaryFocus: string;
    timestamp: string;
  };
}

export interface SetContextError {
  success: false;
  error: string;
  details?: string;
}

export type SetContextResult = SetContextSuccess | SetContextError;

// ============================================================================
// Functional Helpers
// ============================================================================

const tryCatch = <T>(fn: () => T, errorMsg: string): Result<T> => {
  try {
    return { success: true, data: fn() };
  } catch (error) {
    return {
      success: false,
      error: errorMsg,
      details: error instanceof Error ? error.message : String(error),
    };
  }
};

const chain = <A, B>(result: Result<A>, f: (data: A) => Result<B>): Result<B> =>
  match(result)
    .with({ success: true }, ({ data }) => f(data))
    .otherwise((error) => error);

const readYaml = (path: string): Result<unknown> =>
  pipe(
    tryCatch(() => readFileSync(path, 'utf-8'), `Failed to read ${path}`),
    (r) => chain(r, (content) => tryCatch(() => yaml.load(content), 'Invalid YAML'))
  );

const validateSchema = <T>(schema: z.ZodSchema<T>, data: unknown, name: string): Result<T> => {
  const validation = schema.safeParse(data);
  return validation.success
    ? { success: true, data: validation.data }
    : { success: false, error: `${name} validation failed`, details: formatZodError(validation.error) };
};

const generateContextYaml = (name: string, meta: z.infer<typeof MetadataSchema>, ts: string) => `# Auto-generated by /tailor command
# Last updated: ${ts}
# Active company: ${name}

active_company: '${name}'
company: '${meta.company}'
folder_path: '${meta.folder_path}'
available_files:
${meta.available_files.map((f) => `  - '${f}'`).join('\n')}
active_template: '${meta.active_template}'
position: '${meta.position}'
primary_focus: '${meta.primary_focus}'
job_summary: '${meta.job_summary}'
job_details:
  company: '${meta.job_details.company}'
  location: '${meta.job_details.location}'
  experience_level: '${meta.job_details.experience_level}'
  employment_type: '${meta.job_details.employment_type}'
  must_have_skills:
${meta.job_details.must_have_skills.map((s) => `    - '${s}'`).join('\n')}
  nice_to_have_skills:
${meta.job_details.nice_to_have_skills.map((s) => `    - '${s}'`).join('\n')}
  team_context: '${meta.job_details.team_context}'
  user_scale: '${meta.job_details.user_scale}'
last_updated: '${ts}'
`;

/**
 * Validates and sets the tailor context for a specific company
 */
export function setTailorContext(companyName: string): SetContextResult {
  const base = 'resume-data/tailor';
  const companyPath = join(base, companyName);
  const paths = {
    metadata: join(companyPath, 'metadata.yaml'),
    jobAnalysis: join(companyPath, 'job_analysis.yaml'),
    context: '.claude/tailor-context.yaml',
  };

  // Validate paths
  if (!existsSync(companyPath)) {
    return {
      success: false,
      error: `Company folder not found: ${companyPath}`,
      details: `Available companies: ${getAvailableCompanies(base).join(', ') || 'none'}`,
    };
  }
  if (!existsSync(paths.metadata)) {
    return { success: false, error: `metadata.yaml not found in ${companyPath}` };
  }
  if (!existsSync(paths.jobAnalysis)) {
    return { success: false, error: `job_analysis.yaml not found in ${companyPath}` };
  }

  // Read and validate
  const metadata = pipe(
    readYaml(paths.metadata),
    (r) => chain(r, (d) => validateSchema(MetadataSchema, d, 'metadata.yaml'))
  );

  const jobAnalysis = pipe(
    readYaml(paths.jobAnalysis),
    (r) => chain(r, (d) => validateSchema(JobAnalysisSchema, (d as any)?.job_analysis || d, 'job_analysis.yaml'))
  );

  // Combine and write
  return match([metadata, jobAnalysis] as const)
    .with([{ success: true }, { success: true }], ([{ data: meta }]) => {
      const ts = new Date().toISOString();
      const yaml = generateContextYaml(companyName, meta, ts);
      const write = tryCatch(() => writeFileSync(paths.context, yaml, 'utf-8'), 'Failed to write context');

      return write.success
        ? {
            success: true as const,
            data: {
              company: meta.company,
              path: meta.folder_path,
              availableFiles: meta.available_files,
              position: meta.position,
              primaryFocus: meta.primary_focus,
              timestamp: ts,
            },
          }
        : write;
    })
    .with([{ success: false }, P._], ([err]) => err)
    .with([P._, { success: false }], ([, err]) => err)
    .exhaustive();
}

const getAvailableCompanies = (base: string): string[] => {
  if (!existsSync(base)) return [];
  try {
    return readdirSync(base, { withFileTypes: true })
      .filter((d) => d.isDirectory())
      .map((d) => d.name);
  } catch {
    return [];
  }
};

const formatZodError = (error: z.ZodError): string =>
  error.issues
    .map((i) => `  - ${i.path.length > 0 ? i.path.join('.') : 'root'}: ${i.message}`)
    .join('\n');
