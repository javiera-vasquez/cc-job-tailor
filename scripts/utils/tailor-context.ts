import { existsSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import { join } from 'path';
import yaml from 'js-yaml';
import { MetadataSchema, JobAnalysisSchema } from '../../src/zod/schemas';
import type { z } from 'zod';

export interface SetContextSuccess {
  success: true;
  data: {
    company: string;
    path: string;
    availableFiles: string[];
    position: string;
    primaryFocus: string;
    timestamp: string;
  };
}

export interface SetContextError {
  success: false;
  error: string;
  details?: string;
}

export type SetContextResult = SetContextSuccess | SetContextError;

/**
 * Validates and sets the tailor context for a specific company
 * @param companyName - The company folder name (e.g., 'tech-corp')
 * @returns Result object with success status and data or error message
 */
export function setTailorContext(companyName: string): SetContextResult {
  const tailorBasePath = 'resume-data/tailor';
  const companyPath = join(tailorBasePath, companyName);
  const metadataPath = join(companyPath, 'metadata.yaml');
  const jobAnalysisPath = join(companyPath, 'job_analysis.yaml');
  const contextPath = '.claude/tailor-context.yaml';

  // 1. Validate folder exists
  if (!existsSync(companyPath)) {
    return {
      success: false,
      error: `Company folder not found: ${companyPath}`,
      details: `Expected folder at: ${companyPath}\nAvailable companies: ${getAvailableCompanies(tailorBasePath).join(', ') || 'none'}`,
    };
  }

  // 2. Validate metadata.yaml exists
  if (!existsSync(metadataPath)) {
    return {
      success: false,
      error: `metadata.yaml not found in ${companyPath}`,
      details: `Required file: ${metadataPath}\nPlease ensure the company folder has a metadata.yaml file.`,
    };
  }

  // 3. Validate job_analysis.yaml exists
  if (!existsSync(jobAnalysisPath)) {
    return {
      success: false,
      error: `job_analysis.yaml not found in ${companyPath}`,
      details: `Required file: ${jobAnalysisPath}\nPlease ensure the company folder has a job_analysis.yaml file.`,
    };
  }

  // 4. Parse YAML files
  let metadataContent: unknown;
  let jobAnalysisContent: unknown;

  try {
    const metadataRaw = readFileSync(metadataPath, 'utf-8');
    metadataContent = yaml.load(metadataRaw);
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse metadata.yaml`,
      details: error instanceof Error ? error.message : String(error),
    };
  }

  try {
    const jobAnalysisRaw = readFileSync(jobAnalysisPath, 'utf-8');
    const parsed = yaml.load(jobAnalysisRaw) as any;
    // Extract the nested job_analysis object
    jobAnalysisContent = parsed?.job_analysis || parsed;
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse job_analysis.yaml`,
      details: error instanceof Error ? error.message : String(error),
    };
  }

  // 5. Validate with Zod schemas
  const metadataValidation = MetadataSchema.safeParse(metadataContent);
  if (!metadataValidation.success) {
    return {
      success: false,
      error: `metadata.yaml validation failed`,
      details: formatZodError(metadataValidation.error),
    };
  }

  const jobAnalysisValidation = JobAnalysisSchema.safeParse(jobAnalysisContent);
  if (!jobAnalysisValidation.success) {
    return {
      success: false,
      error: `job_analysis.yaml validation failed`,
      details: formatZodError(jobAnalysisValidation.error),
    };
  }

  // 6. Update .claude/tailor-context.yaml
  const metadata = metadataValidation.data;
  const timestamp = new Date().toISOString();

  try {
    const contextContent = `# Auto-generated by /tailor command
# Last updated: ${timestamp}
# Active company: ${companyName}

active_company: '${companyName}'
company: '${metadata.company}'
folder_path: '${metadata.folder_path}'
available_files:
${metadata.available_files.map((file) => `  - '${file}'`).join('\n')}
active_template: '${metadata.active_template}'
position: '${metadata.position}'
primary_focus: '${metadata.primary_focus}'
job_summary: '${metadata.job_summary}'
job_details:
  company: '${metadata.job_details.company}'
  location: '${metadata.job_details.location}'
  experience_level: '${metadata.job_details.experience_level}'
  employment_type: '${metadata.job_details.employment_type}'
  must_have_skills:
${metadata.job_details.must_have_skills.map((skill) => `    - '${skill}'`).join('\n')}
  nice_to_have_skills:
${metadata.job_details.nice_to_have_skills.map((skill) => `    - '${skill}'`).join('\n')}
  team_context: '${metadata.job_details.team_context}'
  user_scale: '${metadata.job_details.user_scale}'
last_updated: '${timestamp}'
`;

    writeFileSync(contextPath, contextContent, 'utf-8');
  } catch (error) {
    return {
      success: false,
      error: `Failed to write tailor-context.yaml`,
      details: error instanceof Error ? error.message : String(error),
    };
  }

  // 7. Return success with data
  return {
    success: true,
    data: {
      company: metadata.company,
      path: metadata.folder_path,
      availableFiles: metadata.available_files,
      position: metadata.position,
      primaryFocus: metadata.primary_focus,
      timestamp,
    },
  };
}

/**
 * Get list of available company folders
 */
function getAvailableCompanies(tailorBasePath: string): string[] {
  try {
    if (!existsSync(tailorBasePath)) return [];
    return readdirSync(tailorBasePath, { withFileTypes: true })
      .filter((dirent) => dirent.isDirectory())
      .map((dirent) => dirent.name);
  } catch {
    return [];
  }
}

/**
 * Format Zod validation errors into readable message
 */
function formatZodError(error: z.ZodError): string {
  return error.issues
    .map((issue) => {
      const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
      return `  - ${path}: ${issue.message}`;
    })
    .join('\n');
}
