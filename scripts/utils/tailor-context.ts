import { existsSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import { join } from 'path';
import yaml from 'js-yaml';
import { pipe } from 'remeda';
import { match, P } from 'ts-pattern';
import { MetadataSchema, JobAnalysisSchema } from '../../src/zod/schemas';
import { TailorContextSchema, type TailorContext } from '../../src/zod/tailor-context-schema';
import type { z } from 'zod';

// Result type for functional error handling
export type Result<T, E = { error: string; details?: string }> =
  | { success: true; data: T }
  | ({ success: false } & E);

export interface SetContextSuccess {
  success: true;
  data: {
    company: string;
    path: string;
    availableFiles: string[];
    position: string;
    primaryFocus: string;
    timestamp: string;
  };
}

export interface SetContextError {
  success: false;
  error: string;
  details?: string;
}

export type SetContextResult = SetContextSuccess | SetContextError;

// ============================================================================
// Functional Helpers
// ============================================================================

const tryCatch = <T>(fn: () => T, errorMsg: string): Result<T> => {
  try {
    return { success: true, data: fn() };
  } catch (error) {
    return {
      success: false,
      error: errorMsg,
      details: error instanceof Error ? error.message : String(error),
    };
  }
};

const chain = <A, B>(result: Result<A>, f: (data: A) => Result<B>): Result<B> =>
  match(result)
    .with({ success: true }, ({ data }) => f(data))
    .otherwise((error) => error);

const readYaml = (path: string): Result<unknown> =>
  pipe(
    tryCatch(() => readFileSync(path, 'utf-8'), `Failed to read ${path}`),
    (r) => chain(r, (content) => tryCatch(() => yaml.load(content), 'Invalid YAML')),
  );

const validateSchema = <T>(schema: z.ZodSchema<T>, data: unknown, name: string): Result<T> => {
  const validation = schema.safeParse(data);
  return validation.success
    ? { success: true, data: validation.data }
    : {
        success: false,
        error: `${name} validation failed`,
        details: formatZodError(validation.error),
      };
};

/**
 * Generate YAML content for tailor context using schema-driven approach
 * This is the single source of truth - all YAML generation flows through this function
 */
const generateContextYaml = (
  companyName: string,
  meta: z.infer<typeof MetadataSchema>,
  timestamp: string,
): string => {
  // Construct data object from schema
  // Note: active_template has a default value in MetadataSchema, so it's always defined after parsing
  const contextData: TailorContext = {
    active_company: companyName,
    company: meta.company,
    folder_path: meta.folder_path,
    available_files: meta.available_files,
    active_template: meta.active_template ?? 'modern', // Fallback to 'modern' if somehow undefined
    position: meta.position,
    primary_focus: meta.primary_focus,
    job_summary: meta.job_summary,
    job_details: meta.job_details,
    last_updated: timestamp,
  };

  // Validate against schema before serialization
  const validation = TailorContextSchema.safeParse(contextData);
  if (!validation.success) {
    const errorDetails = formatZodError(validation.error);
    throw new Error(`Context data validation failed:\n${errorDetails}`);
  }

  // Generate YAML with header comments
  const header = [
    '# Auto-generated by /tailor command',
    `# Last updated: ${timestamp}`,
    `# Active company: ${companyName}`,
    '',
  ].join('\n');

  return (
    header +
    yaml.dump(validation.data, {
      indent: 2,
      lineWidth: 120,
      quotingType: '"',
      forceQuotes: false,
    })
  );
};

/**
 * Validates and sets the tailor context for a specific company
 */
export function setTailorContext(companyName: string): SetContextResult {
  const base = 'resume-data/tailor';
  const companyPath = join(base, companyName);
  const paths = {
    metadata: join(companyPath, 'metadata.yaml'),
    jobAnalysis: join(companyPath, 'job_analysis.yaml'),
    context: '.claude/tailor-context.yaml',
  };

  // Validate paths
  if (!existsSync(companyPath)) {
    return {
      success: false,
      error: `Company folder not found: ${companyPath}`,
      details: `Available companies: ${getAvailableCompanies(base).join(', ') || 'none'}`,
    };
  }
  if (!existsSync(paths.metadata)) {
    return { success: false, error: `metadata.yaml not found in ${companyPath}` };
  }
  if (!existsSync(paths.jobAnalysis)) {
    return { success: false, error: `job_analysis.yaml not found in ${companyPath}` };
  }

  // Read and validate
  const metadata = pipe(readYaml(paths.metadata), (r) =>
    chain(r, (d) => validateSchema(MetadataSchema, d, 'metadata.yaml')),
  );

  const jobAnalysis = pipe(readYaml(paths.jobAnalysis), (r) =>
    chain(r, (d) =>
      validateSchema(JobAnalysisSchema, (d as any)?.job_analysis || d, 'job_analysis.yaml'),
    ),
  );

  // Combine and write
  return match([metadata, jobAnalysis] as const)
    .with([{ success: true }, { success: true }], ([{ data: meta }]) => {
      const ts = new Date().toISOString();
      // Ensure active_template has its default value applied
      const metaWithTemplate = {
        ...meta,
        active_template: meta.active_template ?? ('modern' as const),
      };
      const yaml = generateContextYaml(companyName, metaWithTemplate, ts);
      const write = tryCatch(
        () => writeFileSync(paths.context, yaml, 'utf-8'),
        'Failed to write context',
      );

      return write.success
        ? {
            success: true as const,
            data: {
              company: meta.company,
              path: meta.folder_path,
              availableFiles: meta.available_files,
              position: meta.position,
              primaryFocus: meta.primary_focus,
              timestamp: ts,
            },
          }
        : write;
    })
    .with([{ success: false }, P._], ([err]) => err)
    .with([P._, { success: false }], ([, err]) => err)
    .exhaustive();
}

const getAvailableCompanies = (base: string): string[] => {
  if (!existsSync(base)) return [];
  try {
    return readdirSync(base, { withFileTypes: true })
      .filter((d) => d.isDirectory())
      .map((d) => d.name);
  } catch {
    return [];
  }
};

const formatZodError = (error: z.ZodError): string =>
  error.issues
    .map((i) => `  - ${i.path.length > 0 ? i.path.join('.') : 'root'}: ${i.message}`)
    .join('\n');
