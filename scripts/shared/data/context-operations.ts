import { writeFileSync } from 'fs';
import yaml from 'js-yaml';
import type { z } from 'zod';
import type { Result, FileToValidateWithYamlData, SetContextSuccess } from '../validation/validation-pipeline';
import { formatZodError } from '../validation/validation-pipeline';
import { tryCatch } from '../core/functional-utils';
import { MetadataSchema } from '../../../src/zod/schemas';
import { TailorContextSchema, type TailorContext } from '../../../src/zod/tailor-context-schema';
import type { CompanyFileValue } from '../core/config';

/**
 * Generates YAML content for tailor-context.yaml using schema-driven approach.
 *
 * Creates TailorContext object from metadata, validates against TailorContextSchema,
 * and serializes to YAML with header comments. This is the single source of truth
 * for YAML generation.
 *
 * @param {string} companyName - Company name for active_company field
 * @param {MetadataSchema} meta - Validated metadata with active_template default
 * @param {string} timestamp - ISO timestamp for last_updated field
 * @returns {string} YAML string with header comments
 * @throws {Error} If context data fails TailorContextSchema validation
 */
export const generateContextYaml = (
  companyName: string,
  meta: z.infer<typeof MetadataSchema>,
  timestamp: string,
): string => {
  const contextData: TailorContext = {
    active_company: companyName,
    company: meta.company,
    folder_path: meta.folder_path,
    available_files: meta.available_files,
    active_template: meta.active_template ?? 'modern',
    position: meta.position,
    primary_focus: meta.primary_focus,
    job_summary: meta.job_summary,
    job_details: meta.job_details,
    last_updated: timestamp,
  };

  const validation = TailorContextSchema.safeParse(contextData);
  if (!validation.success) {
    const errorDetails = formatZodError(validation.error);
    throw new Error(`Context data validation failed:\n${errorDetails}`);
  }

  const header = [
    '# Auto-generated by /tailor command',
    `# Last updated: ${timestamp}`,
    `# Active company: ${companyName}`,
    '',
  ].join('\n');

  return (
    header +
    yaml.dump(validation.data, {
      indent: 2,
      lineWidth: 120,
      quotingType: '"',
      forceQuotes: false,
    })
  );
};

/**
 * Extracts metadata from the validated files array by fileName.
 *
 * Searches the files array for the metadata file and returns its validated data.
 *
 * @param {FileToValidateWithYamlData[]} files - Array of validated files with data
 * @param {CompanyFileValue} fileName - File name to search for (typically COMPANY_FILES.METADATA)
 * @returns {Result<MetadataSchema>} Result containing metadata or error if not found
 */
export const extractMetadata = (
  files: FileToValidateWithYamlData[],
  fileName: CompanyFileValue,
): Result<z.infer<typeof MetadataSchema>> => {
  const metadataFile = files.find((f) => f.fileName === fileName);
  return metadataFile
    ? { success: true, data: metadataFile.data as z.infer<typeof MetadataSchema> }
    : { success: false, error: 'Metadata file not found in validated files' };
};

/**
 * Generates and writes the tailor-context.yaml file with company metadata.
 *
 * Creates the YAML context configuration with schema validation, header comments,
 * and timestamp. Ensures active_template has a default value if not specified.
 *
 * @param {string} companyName - Company name for context
 * @param {MetadataSchema} metadata - Validated metadata from company files
 * @param {string} contextPath - Absolute path to write tailor-context.yaml
 * @returns {Result<SetContextSuccess['data']>} Result containing context summary or write error
 */
export const generateAndWriteTailorContext = (
  companyName: string,
  metadata: z.infer<typeof MetadataSchema>,
  contextPath: string,
): Result<SetContextSuccess['data']> => {
  const ts = new Date().toISOString();
  const metaWithTemplate = {
    ...metadata,
    active_template: metadata.active_template ?? ('modern' as const),
  };

  const yaml_content = generateContextYaml(companyName, metaWithTemplate, ts);
  const write = tryCatch(
    () => writeFileSync(contextPath, yaml_content, 'utf-8'),
    'Failed to write context',
  );

  return write.success
    ? {
        success: true as const,
        data: {
          company: metadata.company,
          path: metadata.folder_path,
          availableFiles: metadata.available_files,
          position: metadata.position,
          primaryFocus: metadata.primary_focus,
          timestamp: ts,
        },
      }
    : write;
};
